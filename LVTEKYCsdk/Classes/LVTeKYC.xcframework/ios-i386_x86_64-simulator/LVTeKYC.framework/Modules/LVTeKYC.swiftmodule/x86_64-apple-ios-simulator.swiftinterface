// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.1 (swiftlang-1200.0.41 clang-1200.0.32.8)
// swift-module-flags: -target x86_64-apple-ios10.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name LVTeKYC
import AVFoundation
import CoreGraphics
import CoreImage
import CoreMedia
import Dispatch
import FirebaseCore
import FirebaseMLVision
import Foundation
@_exported import LVTeKYC
import MobileCoreServices
import LVTeKYC.Private
import Security
import Swift
import SystemConfiguration
import UIKit
@_hasMissingDesignatedInitializers open class CGFloatTransform : LVTeKYC.TransformType {
  public typealias Object = CoreGraphics.CGFloat
  public typealias JSON = Swift.String
  public func transformFromJSON(_ value: Any?) -> CoreGraphics.CGFloat?
  public func transformToJSON(_ value: CoreGraphics.CGFloat?) -> Swift.String?
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class SDKConfig : ObjectiveC.NSObject {
  @objc public static var ocrGuideTitle: Swift.String?
  @objc public static var ocrGuideTooBlurImage: UIKit.UIImage?
  @objc public static var ocrGuideTakeOffEdgeImage: UIKit.UIImage?
  @objc public static var ocrGuideOverExpoesedImage: UIKit.UIImage?
  @objc public static var ocrGuideTextLine1: Swift.String?
  @objc public static var ocrGuideTextLine2: Swift.String?
  @objc public static var ocrGuideTextLine3: Swift.String?
  @objc public static var ocrGuideButtonText: Swift.String?
  @objc public static var ocrTitle: Swift.String?
  @objc public static var ocrCaptureFrontHint: Swift.String?
  @objc public static var ocrCaptureBackHint: Swift.String?
  @objc public static var ocrCaptureBottomHint: Swift.String?
  @objc public static var ocrContinueButtonTitle: Swift.String?
  @objc public static var ocrRetakeButtonTitle: Swift.String?
  @objc public static var fmlcTitle: Swift.String?
  @objc public static var fmlcSubtitle: Swift.String?
  @objc public static var fmlcInstructionStep4: Swift.String?
  @objc deinit
  @objc override dynamic public init()
}
@_inheritsConvenienceInitializers @objc public class LVTEKYCFaceData : ObjectiveC.NSObject, LVTeKYC.Mappable, Swift.Codable {
  @objc public var confidence: Swift.Double
  @objc public var verifyResult: Swift.String?
  @objc public var liveness: Swift.String?
  @objc override dynamic public init()
  required public init?(map: LVTeKYC.Map)
  public func mapping(map: LVTeKYC.Map)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers open class DoubleTransform : LVTeKYC.TransformType {
  public typealias Object = Swift.Double
  public typealias JSON = Swift.String
  public func transformFromJSON(_ value: Any?) -> Swift.Double?
  public func transformToJSON(_ value: Swift.Double?) -> Swift.String?
  @objc deinit
}
public typealias Image = UIKit.UIImage
@_hasMissingDesignatedInitializers open class RequestReceipt {
  final public let request: LVTeKYC.Request
  final public let receiptID: Swift.String
  @objc deinit
}
open class ImageDownloader {
  public typealias CompletionHandler = (LVTeKYC.DataResponse<LVTeKYC.Image>) -> Swift.Void
  public typealias ProgressHandler = LVTeKYC.DataRequest.ProgressHandler
  public enum DownloadPrioritization {
    case fifo, lifo
    public static func == (a: LVTeKYC.ImageDownloader.DownloadPrioritization, b: LVTeKYC.ImageDownloader.DownloadPrioritization) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let imageCache: LVTeKYC.ImageRequestCache?
  open var credential: Foundation.URLCredential? {
    get
  }
  public var imageResponseSerializer: LVTeKYC.DataResponseSerializer<LVTeKYC.Image>
  final public let sessionManager: LVTeKYC.AlamofireSessionManager
  public static let `default`: LVTeKYC.ImageDownloader
  open class func defaultURLSessionConfiguration() -> Foundation.URLSessionConfiguration
  open class func defaultURLCache() -> Foundation.URLCache
  public init(configuration: Foundation.URLSessionConfiguration = ImageDownloader.defaultURLSessionConfiguration(), downloadPrioritization: LVTeKYC.ImageDownloader.DownloadPrioritization = .fifo, maximumActiveDownloads: Swift.Int = 4, imageCache: LVTeKYC.ImageRequestCache? = AutoPurgingImageCache())
  public init(sessionManager: LVTeKYC.AlamofireSessionManager, downloadPrioritization: LVTeKYC.ImageDownloader.DownloadPrioritization = .fifo, maximumActiveDownloads: Swift.Int = 4, imageCache: LVTeKYC.ImageRequestCache? = AutoPurgingImageCache())
  open func addAuthentication(user: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession)
  open func addAuthentication(usingCredential credential: Foundation.URLCredential)
  @discardableResult
  open func download(_ urlRequest: LVTeKYC.URLRequestConvertible, receiptID: Swift.String = UUID().uuidString, filter: LVTeKYC.ImageFilter? = nil, progress: LVTeKYC.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: LVTeKYC.ImageDownloader.CompletionHandler?) -> LVTeKYC.RequestReceipt?
  @discardableResult
  open func download(_ urlRequests: [LVTeKYC.URLRequestConvertible], filter: LVTeKYC.ImageFilter? = nil, progress: LVTeKYC.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: LVTeKYC.ImageDownloader.CompletionHandler? = nil) -> [LVTeKYC.RequestReceipt]
  open func cancelRequest(with requestReceipt: LVTeKYC.RequestReceipt)
  @objc deinit
}
public typealias ControlState = UIKit.UIControl.State
extension UIButton {
  public var af_imageDownloader: LVTeKYC.ImageDownloader? {
    get
    set
  }
  public class var af_sharedImageDownloader: LVTeKYC.ImageDownloader {
    get
    set
  }
  public func af_setImage(for state: LVTeKYC.ControlState, url: Foundation.URL, placeholderImage: UIKit.UIImage? = nil, filter: LVTeKYC.ImageFilter? = nil, progress: LVTeKYC.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((LVTeKYC.DataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func af_setImage(for state: LVTeKYC.ControlState, urlRequest: LVTeKYC.URLRequestConvertible, placeholderImage: UIKit.UIImage? = nil, filter: LVTeKYC.ImageFilter? = nil, progress: LVTeKYC.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((LVTeKYC.DataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func af_cancelImageRequest(for state: LVTeKYC.ControlState)
  public func af_setBackgroundImage(for state: LVTeKYC.ControlState, url: Foundation.URL, placeholderImage: UIKit.UIImage? = nil, filter: LVTeKYC.ImageFilter? = nil, progress: LVTeKYC.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((LVTeKYC.DataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func af_setBackgroundImage(for state: LVTeKYC.ControlState, urlRequest: LVTeKYC.URLRequestConvertible, placeholderImage: UIKit.UIImage? = nil, filter: LVTeKYC.ImageFilter? = nil, progress: LVTeKYC.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, completion: ((LVTeKYC.DataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func af_cancelBackgroundImageRequest(for state: LVTeKYC.ControlState)
}
public enum AFIError : Swift.Error {
  case requestCancelled
  case imageSerializationFailed
  public static func == (a: LVTeKYC.AFIError, b: LVTeKYC.AFIError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension AFIError {
  public var isRequestCancelledError: Swift.Bool {
    get
  }
  public var isImageSerializationFailedError: Swift.Bool {
    get
  }
}
extension AFIError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class SampleSDKInitRes : ObjectiveC.NSObject, Swift.Codable {
  final public let responseCode: Swift.String, responseMessage: Swift.String, responseTime: Swift.String, signature: Swift.String
  final public let sdkId: Swift.String, tempSecretKey: Swift.String, tempPublicKey: Swift.String
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol MapContext {
}
final public class Map {
  final public let mappingType: LVTeKYC.MappingType
  final public var JSON: [Swift.String : Any] {
    get
  }
  final public var isKeyPresent: Swift.Bool {
    get
  }
  final public var currentValue: Any? {
    get
  }
  final public var currentKey: Swift.String? {
    get
  }
  final public var nestedKeyDelimiter: Swift.String {
    get
  }
  final public var context: LVTeKYC.MapContext?
  final public var shouldIncludeNilValues: Swift.Bool
  final public let toObject: Swift.Bool
  public init(mappingType: LVTeKYC.MappingType, JSON: [Swift.String : Any], toObject: Swift.Bool = false, context: LVTeKYC.MapContext? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public subscript(key: Swift.String) -> LVTeKYC.Map {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String) -> LVTeKYC.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool) -> LVTeKYC.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, delimiter delimiter: Swift.String) -> LVTeKYC.Map {
    get
  }
  final public subscript(key: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> LVTeKYC.Map {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> LVTeKYC.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, ignoreNil ignoreNil: Swift.Bool) -> LVTeKYC.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool?, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> LVTeKYC.Map {
    get
  }
  final public func value<T>() -> T?
  @objc deinit
}
extension Map {
  final public func value<T>(_ key: Swift.String, default: T.Object, using transform: T) throws -> T.Object where T : LVTeKYC.TransformType
  final public func value<T>(_ key: Swift.String, default: T) throws -> T
  final public func value<T>(_ key: Swift.String, default: [T]) -> [T] where T : LVTeKYC.BaseMappable
  final public func value<T>(_ key: Swift.String, default: T) throws -> T where T : LVTeKYC.BaseMappable
}
public struct MapError : Swift.Error {
  public var key: Swift.String?
  public var currentValue: Any?
  public var reason: Swift.String?
  public var file: Swift.StaticString?
  public var function: Swift.StaticString?
  public var line: Swift.UInt?
  public init(key: Swift.String?, currentValue: Any?, reason: Swift.String?, file: Swift.StaticString? = nil, function: Swift.StaticString? = nil, line: Swift.UInt? = nil)
}
extension MapError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class SampleService {
  public static func requestInitKey(completion: @escaping (LVTeKYC.SampleSDKInitRes?, Swift.Error?) -> Swift.Void)
  public static func login(req: LVTeKYC.SampleSDKLoginReq, completion: @escaping (LVTeKYC.SampleSDKLoginRes?, Swift.Error?) -> Swift.Void)
  public static func startSession(req: LVTeKYC.SampleSDKStartSessionReq, completion: @escaping (LVTeKYC.SampleSDKStartSessionRes?, Swift.Error?) -> Swift.Void)
  public static func updateResult(req: LVTeKYC.SampleSDKUpdateResultReq, completion: @escaping (LVTeKYC.SampleSDKUpdateResultRes?, Swift.Error?) -> Swift.Void)
  @objc deinit
}
extension UIImage {
  public static func af_threadSafeImage(with data: Foundation.Data) -> UIKit.UIImage?
  public static func af_threadSafeImage(with data: Foundation.Data, scale: CoreGraphics.CGFloat) -> UIKit.UIImage?
}
extension UIImage {
  public var af_inflated: Swift.Bool {
    get
    set
  }
  public func af_inflate()
}
extension UIImage {
  public var af_containsAlphaComponent: Swift.Bool {
    get
  }
  public var af_isOpaque: Swift.Bool {
    get
  }
}
extension UIImage {
  public func af_imageScaled(to size: CoreGraphics.CGSize) -> UIKit.UIImage
  public func af_imageAspectScaled(toFit size: CoreGraphics.CGSize) -> UIKit.UIImage
  public func af_imageAspectScaled(toFill size: CoreGraphics.CGSize) -> UIKit.UIImage
}
extension UIImage {
  public func af_imageRounded(withCornerRadius radius: CoreGraphics.CGFloat, divideRadiusByImageScale: Swift.Bool = false) -> UIKit.UIImage
  public func af_imageRoundedIntoCircle() -> UIKit.UIImage
}
@available(iOS 9.0, *)
extension UIImage {
  public func af_imageFiltered(withCoreImageFilter name: Swift.String, parameters: [Swift.String : Any]? = nil) -> UIKit.UIImage?
}
public struct Color {
  public static let navBackgroundColor: UIKit.UIColor
  public static let appBackgroundColor: UIKit.UIColor
  public static let searchVCTableViewHeaderBgColor: UIKit.UIColor
  public static let defaultPlaceholderColor: UIKit.UIColor
  public static let separatorColor: UIKit.UIColor
  public static let tableViewSeparatorColor: UIKit.UIColor
}
public func <- <T>(left: inout T, right: LVTeKYC.Map) where T : Swift.SignedInteger
public func <- <T>(left: inout T?, right: LVTeKYC.Map) where T : Swift.SignedInteger
public func <- <T>(left: inout T, right: LVTeKYC.Map) where T : Swift.UnsignedInteger
public func <- <T>(left: inout T?, right: LVTeKYC.Map) where T : Swift.UnsignedInteger
open class AlamofireSessionManager {
  public enum MultipartFormDataEncodingResult {
    case success(request: LVTeKYC.UploadRequest, streamingFromDisk: Swift.Bool, streamFileURL: Foundation.URL?)
    case failure(Swift.Error)
  }
  public static let `default`: LVTeKYC.AlamofireSessionManager
  public static let defaultHTTPHeaders: LVTeKYC.HTTPHeaders
  public static let multipartFormDataEncodingMemoryThreshold: Swift.UInt64
  final public let session: Foundation.URLSession
  final public let delegate: LVTeKYC.SessionDelegate
  open var startRequestsImmediately: Swift.Bool
  open var adapter: LVTeKYC.RequestAdapter?
  open var retrier: LVTeKYC.RequestRetrier? {
    get
    set
  }
  open var backgroundCompletionHandler: (() -> Swift.Void)?
  public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.default, delegate: LVTeKYC.SessionDelegate = SessionDelegate(), serverTrustPolicyManager: LVTeKYC.ServerTrustPolicyManager? = nil)
  public init?(session: Foundation.URLSession, delegate: LVTeKYC.SessionDelegate, serverTrustPolicyManager: LVTeKYC.ServerTrustPolicyManager? = nil)
  @objc deinit
  @discardableResult
  open func request(_ url: LVTeKYC.URLConvertible, method: LVTeKYC.HTTPMethod = .get, parameters: LVTeKYC.Parameters? = nil, encoding: LVTeKYC.ParameterEncoding = URLEncoding.default, headers: LVTeKYC.HTTPHeaders? = nil) -> LVTeKYC.DataRequest
  @discardableResult
  open func request(_ urlRequest: LVTeKYC.URLRequestConvertible) -> LVTeKYC.DataRequest
  @discardableResult
  open func download(_ url: LVTeKYC.URLConvertible, method: LVTeKYC.HTTPMethod = .get, parameters: LVTeKYC.Parameters? = nil, encoding: LVTeKYC.ParameterEncoding = URLEncoding.default, headers: LVTeKYC.HTTPHeaders? = nil, to destination: LVTeKYC.DownloadRequest.DownloadFileDestination? = nil) -> LVTeKYC.DownloadRequest
  @discardableResult
  open func download(_ urlRequest: LVTeKYC.URLRequestConvertible, to destination: LVTeKYC.DownloadRequest.DownloadFileDestination? = nil) -> LVTeKYC.DownloadRequest
  @discardableResult
  open func download(resumingWith resumeData: Foundation.Data, to destination: LVTeKYC.DownloadRequest.DownloadFileDestination? = nil) -> LVTeKYC.DownloadRequest
  @discardableResult
  open func upload(_ fileURL: Foundation.URL, to url: LVTeKYC.URLConvertible, method: LVTeKYC.HTTPMethod = .post, headers: LVTeKYC.HTTPHeaders? = nil) -> LVTeKYC.UploadRequest
  @discardableResult
  open func upload(_ fileURL: Foundation.URL, with urlRequest: LVTeKYC.URLRequestConvertible) -> LVTeKYC.UploadRequest
  @discardableResult
  open func upload(_ data: Foundation.Data, to url: LVTeKYC.URLConvertible, method: LVTeKYC.HTTPMethod = .post, headers: LVTeKYC.HTTPHeaders? = nil) -> LVTeKYC.UploadRequest
  @discardableResult
  open func upload(_ data: Foundation.Data, with urlRequest: LVTeKYC.URLRequestConvertible) -> LVTeKYC.UploadRequest
  @discardableResult
  open func upload(_ stream: Foundation.InputStream, to url: LVTeKYC.URLConvertible, method: LVTeKYC.HTTPMethod = .post, headers: LVTeKYC.HTTPHeaders? = nil) -> LVTeKYC.UploadRequest
  @discardableResult
  open func upload(_ stream: Foundation.InputStream, with urlRequest: LVTeKYC.URLRequestConvertible) -> LVTeKYC.UploadRequest
  open func upload(multipartFormData: @escaping (LVTeKYC.MultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = AlamofireSessionManager.multipartFormDataEncodingMemoryThreshold, to url: LVTeKYC.URLConvertible, method: LVTeKYC.HTTPMethod = .post, headers: LVTeKYC.HTTPHeaders? = nil, queue: Dispatch.DispatchQueue? = nil, encodingCompletion: ((LVTeKYC.AlamofireSessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
  open func upload(multipartFormData: @escaping (LVTeKYC.MultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = AlamofireSessionManager.multipartFormDataEncodingMemoryThreshold, with urlRequest: LVTeKYC.URLRequestConvertible, queue: Dispatch.DispatchQueue? = nil, encodingCompletion: ((LVTeKYC.AlamofireSessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  @discardableResult
  open func stream(withHostName hostName: Swift.String, port: Swift.Int) -> LVTeKYC.StreamRequest
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  @discardableResult
  open func stream(with netService: Foundation.NetService) -> LVTeKYC.StreamRequest
}
@objc @_inheritsConvenienceInitializers public class SampleSDKStartSessionRes : ObjectiveC.NSObject, Swift.Codable {
  public var responseCode: Swift.String?
  public var responseMessage: Swift.String?
  public var responseTime: Swift.String?
  public var signature: Swift.String?
  public var ekycSessionId: Swift.String?
  public var sdkId: Swift.String?
  public var ekycSessionScope: Swift.String?
  public var userId: Swift.String?
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
open class MultipartFormData {
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  public var boundary: Swift.String
  public init()
  public func append(_ data: Foundation.Data, withName name: Swift.String)
  public func append(_ data: Foundation.Data, withName name: Swift.String, mimeType: Swift.String)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: LVTeKYC.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
extension DataRequest {
  public class func addAcceptableImageContentTypes(_ contentTypes: Swift.Set<Swift.String>)
  public class func imageResponseSerializer(imageScale: CoreGraphics.CGFloat = DataRequest.imageScale, inflateResponseImage: Swift.Bool = true) -> LVTeKYC.DataResponseSerializer<LVTeKYC.Image>
  @discardableResult
  public func responseImage(imageScale: CoreGraphics.CGFloat = DataRequest.imageScale, inflateResponseImage: Swift.Bool = true, queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (LVTeKYC.DataResponse<LVTeKYC.Image>) -> Swift.Void) -> Self
  @discardableResult
  public func streamImage(imageScale: CoreGraphics.CGFloat = DataRequest.imageScale, inflateResponseImage: Swift.Bool = true, completionHandler: @escaping (LVTeKYC.Image) -> Swift.Void) -> Self
  public class var imageScale: CoreGraphics.CGFloat {
    get
  }
  public class func validateContentType(for request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) throws
}
@_hasMissingDesignatedInitializers open class BooleanTransform : LVTeKYC.TransformType {
  public typealias Object = Swift.Bool
  public typealias JSON = Swift.String
  public func transformFromJSON(_ value: Any?) -> Swift.Bool?
  public func transformToJSON(_ value: Swift.Bool?) -> Swift.String?
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class LVTEKYCsdk : ObjectiveC.NSObject {
  @objc public static func isInitial() -> Swift.Bool
  @objc public static func getSdkId() -> Swift.String?
  @objc public static func sdkInit(_ initParams: LVTeKYC.SDKInitParams, successCallback: @escaping () -> Swift.Void, failureCallback: @escaping (LVTeKYC.SDKError) -> Swift.Void)
  @objc public static func starteKYC(from fromVC: UIKit.UIViewController, animated animateFlag: Swift.Bool = true, config: LVTeKYC.EKYCConfiguration, successCallback: @escaping (LVTeKYC.SDKResultData, UIKit.UINavigationController?) -> Swift.Void, failureCallback: @escaping (LVTeKYC.SDKError, UIKit.UINavigationController?) -> Swift.Void, logTraceIdCallback: @escaping (Swift.String) -> Swift.Void)
  @objc public static func starteKYC(_ config: LVTeKYC.EKYCConfiguration, successCallback: @escaping (LVTeKYC.SDKResultData, UIKit.UINavigationController?) -> Swift.Void, failureCallback: @escaping (LVTeKYC.SDKError, UIKit.UINavigationController?) -> Swift.Void, logTraceIdCallback: @escaping (Swift.String) -> Swift.Void)
  @objc deinit
  @objc override dynamic public init()
}
extension LVTEKYCsdk {
  @objc public static func application(_ application: UIKit.UIApplication, didFinishLaunchingWithOptions launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?)
}
public struct DefaultDataResponse {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let error: Swift.Error?
  public let timeline: LVTeKYC.Timeline
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?, timeline: LVTeKYC.Timeline = Timeline(), metrics: Swift.AnyObject? = nil)
}
public struct DataResponse<Value> {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let result: LVTeKYC.Result<Value>
  public let timeline: LVTeKYC.Timeline
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, result: LVTeKYC.Result<Value>, timeline: LVTeKYC.Timeline = Timeline())
}
extension DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension DataResponse {
  public func map<T>(_ transform: (Value) -> T) -> LVTeKYC.DataResponse<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> LVTeKYC.DataResponse<T>
  public func mapError<E>(_ transform: (Swift.Error) -> E) -> LVTeKYC.DataResponse<Value> where E : Swift.Error
  public func flatMapError<E>(_ transform: (Swift.Error) throws -> E) -> LVTeKYC.DataResponse<Value> where E : Swift.Error
}
public struct DefaultDownloadResponse {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let temporaryURL: Foundation.URL?
  public let destinationURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let error: Swift.Error?
  public let timeline: LVTeKYC.Timeline
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, temporaryURL: Foundation.URL?, destinationURL: Foundation.URL?, resumeData: Foundation.Data?, error: Swift.Error?, timeline: LVTeKYC.Timeline = Timeline(), metrics: Swift.AnyObject? = nil)
}
public struct DownloadResponse<Value> {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let temporaryURL: Foundation.URL?
  public let destinationURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let result: LVTeKYC.Result<Value>
  public let timeline: LVTeKYC.Timeline
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, temporaryURL: Foundation.URL?, destinationURL: Foundation.URL?, resumeData: Foundation.Data?, result: LVTeKYC.Result<Value>, timeline: LVTeKYC.Timeline = Timeline())
}
extension DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension DownloadResponse {
  public func map<T>(_ transform: (Value) -> T) -> LVTeKYC.DownloadResponse<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> LVTeKYC.DownloadResponse<T>
  public func mapError<E>(_ transform: (Swift.Error) -> E) -> LVTeKYC.DownloadResponse<Value> where E : Swift.Error
  public func flatMapError<E>(_ transform: (Swift.Error) throws -> E) -> LVTeKYC.DownloadResponse<Value> where E : Swift.Error
}
@available(iOS 10.0, OSX 10.12, tvOS 10.0, *)
extension DefaultDataResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, OSX 10.12, tvOS 10.0, *)
extension DataResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, OSX 10.12, tvOS 10.0, *)
extension DefaultDownloadResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, OSX 10.12, tvOS 10.0, *)
extension DownloadResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
public protocol ImmutableMappable : LVTeKYC.BaseMappable {
  init(map: LVTeKYC.Map) throws
}
extension ImmutableMappable {
  public func mapping(map: LVTeKYC.Map)
  public init(JSONString: Swift.String, context: LVTeKYC.MapContext? = nil) throws
  public init(JSON: [Swift.String : Any], context: LVTeKYC.MapContext? = nil) throws
  public init(JSONObject: Any, context: LVTeKYC.MapContext? = nil) throws
}
extension Map {
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> Transform.Object where Transform : LVTeKYC.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T? where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T]? where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : LVTeKYC.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T? where T : LVTeKYC.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : LVTeKYC.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T]? where T : LVTeKYC.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Transform.Object] where Transform : LVTeKYC.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T] where T : LVTeKYC.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T]? where T : LVTeKYC.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : Transform.Object] where Transform : LVTeKYC.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]]? where T : LVTeKYC.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]] where T : LVTeKYC.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[Transform.Object]] where Transform : LVTeKYC.TransformType
}
extension Mapper where N : LVTeKYC.ImmutableMappable {
  final public func map(JSON: [Swift.String : Any]) throws -> N
  final public func map(JSONString: Swift.String) throws -> N
  final public func map(JSONObject: Any) throws -> N
  final public func mapArray(JSONArray: [[Swift.String : Any]]) throws -> [N]
  final public func mapArray(JSONString: Swift.String) throws -> [N]
  final public func mapArray(JSONObject: Any) throws -> [N]
  final public func mapDictionary(JSONString: Swift.String) throws -> [Swift.String : N]
  final public func mapDictionary(JSONObject: Any?) throws -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) throws -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) throws -> [Swift.String : [N]]
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) throws -> [Swift.String : [N]]
  final public func mapArrayOfArrays(JSONObject: Any?) throws -> [[N]]
}
open class DataTransform : LVTeKYC.TransformType {
  public typealias Object = Foundation.Data
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Data?
  open func transformToJSON(_ value: Foundation.Data?) -> Swift.String?
  @objc deinit
}
open class DateTransform : LVTeKYC.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.Double
  public enum Unit : Foundation.TimeInterval {
    case seconds
    case milliseconds
    public typealias RawValue = Foundation.TimeInterval
    public init?(rawValue: Foundation.TimeInterval)
    public var rawValue: Foundation.TimeInterval {
      get
    }
  }
  public init(unit: LVTeKYC.DateTransform.Unit = .seconds)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.Double?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UIUtilities {
  public static func imageOrientation(fromDevicePosition devicePosition: AVFoundation.AVCaptureDevice.Position = .back) -> UIKit.UIImage.Orientation
  public static func visionImageOrientation(from imageOrientation: UIKit.UIImage.Orientation) -> FirebaseMLVision.VisionDetectorImageOrientation
  public static func addCircle(atPoint point: CoreGraphics.CGPoint, to view: UIKit.UIView, color: UIKit.UIColor, radius: CoreGraphics.CGFloat)
  public static func addRectangle(_ rectangle: CoreGraphics.CGRect, to view: UIKit.UIView, color: UIKit.UIColor)
  public static func addShape(withPoints points: [Foundation.NSValue]?, to view: UIKit.UIView, color: UIKit.UIColor)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class ObjectMappable : ObjectiveC.NSObject, LVTeKYC.Mappable {
  @objc override required dynamic public init()
  required public init?(map: LVTeKYC.Map)
  public func mapping(map: LVTeKYC.Map)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
@objc public enum CircleLoadingViewSize : Swift.Int {
  case small = 0
  case medium
  case large
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
open class HexColorTransform : LVTeKYC.TransformType {
  public typealias Object = UIKit.UIColor
  public typealias JSON = Swift.String
  public init(prefixToJSON: Swift.Bool = false, alphaToJSON: Swift.Bool = false)
  open func transformFromJSON(_ value: Any?) -> LVTeKYC.HexColorTransform.Object?
  open func transformToJSON(_ value: LVTeKYC.HexColorTransform.Object?) -> LVTeKYC.HexColorTransform.JSON?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class SampleSDKUpdateResultReq : ObjectiveC.NSObject, Swift.Codable {
  public var serverSignature: Swift.String?
  public var ekycResultTime: Swift.String?
  public var faceData: LVTeKYC.LVTEKYCFaceData?
  public var customerData: LVTeKYC.LVTEKYCCustomerData?
  public var ekycSession: Swift.String?
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  convenience public init(result: LVTeKYC.SDKResultData)
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers open class IntegerTransform : LVTeKYC.TransformType {
  public typealias Object = Swift.Int
  public typealias JSON = Swift.String
  public func transformFromJSON(_ value: Any?) -> Swift.Int?
  public func transformToJSON(_ value: Swift.Int?) -> Swift.String?
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class SDKErrorCode : ObjectiveC.NSObject {
  @objc public static let registerSDKFailed: Swift.String
  @objc public static let sessionIdEmpty: Swift.String
  @objc public static let invalidServiceEndpoint: Swift.String
  @objc public static let invalid3DesKey: Swift.String
  @objc public static let invalidServerPublicKey: Swift.String
  @objc public static let invalidRequestJSON: Swift.String
  @objc public static let encryptBodyError: Swift.String
  @objc public static let invalidResponseJSON: Swift.String
  @objc public static let invalidResponseSecKey: Swift.String
  @objc public static let invalidResponseBodyData: Swift.String
  @objc public static let decryptResponseBody: Swift.String
  @objc public static let goHome: Swift.String
  @objc public static let noInternet: Swift.String
  @objc deinit
  @objc override dynamic public init()
}
public typealias AnimationOptions = UIKit.UIView.AnimationOptions
extension UIImageView {
  public enum ImageTransition {
    case noTransition
    case crossDissolve(Foundation.TimeInterval)
    case curlDown(Foundation.TimeInterval)
    case curlUp(Foundation.TimeInterval)
    case flipFromBottom(Foundation.TimeInterval)
    case flipFromLeft(Foundation.TimeInterval)
    case flipFromRight(Foundation.TimeInterval)
    case flipFromTop(Foundation.TimeInterval)
    case custom(duration: Foundation.TimeInterval, animationOptions: UIKit.UIView.AnimationOptions, animations: (UIKit.UIImageView, LVTeKYC.Image) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)?)
    public var duration: Foundation.TimeInterval {
      get
    }
    public var animationOptions: UIKit.UIView.AnimationOptions {
      get
    }
    public var animations: ((UIKit.UIImageView, LVTeKYC.Image) -> Swift.Void) {
      get
    }
    public var completion: ((Swift.Bool) -> Swift.Void)? {
      get
    }
  }
  public var af_imageDownloader: LVTeKYC.ImageDownloader? {
    get
    set(downloader)
  }
  public class var af_sharedImageDownloader: LVTeKYC.ImageDownloader {
    get
    set
  }
  public func af_setImage(withURL url: Foundation.URL, placeholderImage: UIKit.UIImage? = nil, filter: LVTeKYC.ImageFilter? = nil, progress: LVTeKYC.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, imageTransition: UIKit.UIImageView.ImageTransition = .noTransition, runImageTransitionIfCached: Swift.Bool = false, completion: ((LVTeKYC.DataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func af_setImage(withURLRequest urlRequest: LVTeKYC.URLRequestConvertible, placeholderImage: UIKit.UIImage? = nil, filter: LVTeKYC.ImageFilter? = nil, progress: LVTeKYC.ImageDownloader.ProgressHandler? = nil, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, imageTransition: UIKit.UIImageView.ImageTransition = .noTransition, runImageTransitionIfCached: Swift.Bool = false, completion: ((LVTeKYC.DataResponse<UIKit.UIImage>) -> Swift.Void)? = nil)
  public func af_cancelImageRequest()
  public func run(_ imageTransition: UIKit.UIImageView.ImageTransition, with image: LVTeKYC.Image)
}
public enum MappingType {
  case fromJSON
  case toJSON
  public static func == (a: LVTeKYC.MappingType, b: LVTeKYC.MappingType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class Mapper<N> where N : LVTeKYC.BaseMappable {
  final public var context: LVTeKYC.MapContext?
  final public var shouldIncludeNilValues: Swift.Bool
  public init(context: LVTeKYC.MapContext? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public func map(JSONObject: Any?, toObject object: N) -> N
  final public func map(JSONString: Swift.String, toObject object: N) -> N
  final public func map(JSON: [Swift.String : Any], toObject object: N) -> N
  final public func map(JSONString: Swift.String) -> N?
  final public func map(JSONObject: Any?) -> N?
  final public func map(JSON: [Swift.String : Any]) -> N?
  final public func mapArray(JSONString: Swift.String) -> [N]?
  final public func mapArray(JSONObject: Any?) -> [N]?
  final public func mapArray(JSONArray: [[Swift.String : Any]]) -> [N]
  final public func mapDictionary(JSONString: Swift.String) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?) -> [Swift.String : N]?
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?, toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]], toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) -> [Swift.String : [N]]?
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) -> [Swift.String : [N]]?
  final public func mapArrayOfArrays(JSONObject: Any?) -> [[N]]?
  public static func parseJSONStringIntoDictionary(JSONString: Swift.String) -> [Swift.String : Any]?
  public static func parseJSONString(JSONString: Swift.String) -> Any?
  @objc deinit
}
extension Mapper {
  final public func map(JSONfile: Swift.String) -> N?
  final public func mapArray(JSONfile: Swift.String) -> [N]?
}
extension Mapper {
  final public func toJSON(_ object: N) -> [Swift.String : Any]
  final public func toJSONArray(_ array: [N]) -> [[Swift.String : Any]]
  final public func toJSONDictionary(_ dictionary: [Swift.String : N]) -> [Swift.String : [Swift.String : Any]]
  final public func toJSONDictionaryOfArrays(_ dictionary: [Swift.String : [N]]) -> [Swift.String : [[Swift.String : Any]]]
  final public func toJSONString(_ object: N, prettyPrint: Swift.Bool = false) -> Swift.String?
  final public func toJSONString(_ array: [N], prettyPrint: Swift.Bool = false) -> Swift.String?
  public static func toJSONString(_ JSONObject: Any, prettyPrint: Swift.Bool) -> Swift.String?
  public static func toJSONData(_ JSONObject: Any, options: Foundation.JSONSerialization.WritingOptions) -> Foundation.Data?
}
extension Mapper where N : Swift.Hashable {
  final public func mapSet(JSONString: Swift.String) -> Swift.Set<N>?
  final public func mapSet(JSONObject: Any?) -> Swift.Set<N>?
  final public func mapSet(JSONArray: [[Swift.String : Any]]) -> Swift.Set<N>
  final public func toJSONSet(_ set: Swift.Set<N>) -> [[Swift.String : Any]]
  final public func toJSONString(_ set: Swift.Set<N>, prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Bundle {
  public static let sdk: Foundation.Bundle
}
infix operator <-- : DefaultPrecedence
public func <-- <T>(left: inout Swift.Array<T>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <-- <T>(left: inout Swift.Array<T>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <-- (left: inout [Swift.String], right: LVTeKYC.Map)
public func <-- (left: inout [Swift.String]?, right: LVTeKYC.Map)
open class DateFormatterTransform : LVTeKYC.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  final public let dateFormatter: Foundation.DateFormatter
  public init(dateFormatter: Foundation.DateFormatter)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class OCRImageItem : LVTeKYC.ObjectMappable {
  @objc public var label: Swift.String?
  @objc public var base64: Swift.String?
  @objc required public init(label: Swift.String, base64: Swift.String)
  @objc required dynamic public init()
  required public init?(map: LVTeKYC.Map)
  override public func mapping(map: LVTeKYC.Map)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
open class EnumTransform<T> : LVTeKYC.TransformType where T : Swift.RawRepresentable {
  public typealias Object = T
  public typealias JSON = T.RawValue
  public init()
  open func transformFromJSON(_ value: Any?) -> T?
  open func transformToJSON(_ value: T?) -> T.RawValue?
  @objc deinit
}
extension UIViewController {
  @objc dynamic open func viewDidTapped(_ gesture: UIKit.UITapGestureRecognizer)
}
public enum AFError : Swift.Error {
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case propertyListEncodingFailed(error: Swift.Error)
  }
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNil
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case propertyListSerializationFailed(error: Swift.Error)
  }
  case invalidURL(url: LVTeKYC.URLConvertible)
  case parameterEncodingFailed(reason: LVTeKYC.AFError.ParameterEncodingFailureReason)
  case multipartEncodingFailed(reason: LVTeKYC.AFError.MultipartEncodingFailureReason)
  case responseValidationFailed(reason: LVTeKYC.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: LVTeKYC.AFError.ResponseSerializationFailureReason)
}
extension AFError {
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
}
extension AFError {
  public var urlConvertible: LVTeKYC.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
}
extension AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class ExampleVC : UIKit.UIViewController, LVTeKYC.XibController {
  @objc override dynamic public func viewDidLoad()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_inheritsConvenienceInitializers public class SampleSDKStartSessionReq : ObjectiveC.NSObject, Swift.Codable {
  public var sdkId: Swift.String?
  public var userId: Swift.String?
  public var userSessionId: Swift.String?
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_inheritsConvenienceInitializers @objc public class EKYCConfiguration : ObjectiveC.NSObject {
  @objc public var ekycSession: Swift.String?
  @objc public var ocrTitle: Swift.String?
  @objc public var ocrFrontsideSubtitle: Swift.String?
  @objc public var ocrBacksideSubtitle: Swift.String?
  @objc public var fmlcTitle: Swift.String?
  @objc public var fmlcSubtitle: Swift.String?
  public func setFLMCPoseList(_ poseList: [LVTeKYC.FMLCPoseItem])
  @objc public func setFLMCPoseList(_ poseList: [ObjectiveC.NSInteger])
  @objc deinit
  @objc override dynamic public init()
}
public protocol ImageFilter {
  var filter: (LVTeKYC.Image) -> LVTeKYC.Image { get }
  var identifier: Swift.String { get }
}
extension ImageFilter {
  public var identifier: Swift.String {
    get
  }
}
public protocol Sizable {
  var size: CoreGraphics.CGSize { get }
}
extension ImageFilter where Self : LVTeKYC.Sizable {
  public var identifier: Swift.String {
    get
  }
}
public protocol Roundable {
  var radius: CoreGraphics.CGFloat { get }
}
extension ImageFilter where Self : LVTeKYC.Roundable {
  public var identifier: Swift.String {
    get
  }
}
public struct DynamicImageFilter : LVTeKYC.ImageFilter {
  public let identifier: Swift.String
  public let filter: (LVTeKYC.Image) -> LVTeKYC.Image
  public init(_ identifier: Swift.String, filter: @escaping (LVTeKYC.Image) -> LVTeKYC.Image)
}
public protocol CompositeImageFilter : LVTeKYC.ImageFilter {
  var filters: [LVTeKYC.ImageFilter] { get }
}
extension CompositeImageFilter {
  public var identifier: Swift.String {
    get
  }
  public var filter: (LVTeKYC.Image) -> LVTeKYC.Image {
    get
  }
}
public struct DynamicCompositeImageFilter : LVTeKYC.CompositeImageFilter {
  public let filters: [LVTeKYC.ImageFilter]
  public init(_ filters: [LVTeKYC.ImageFilter])
  public init(_ filters: LVTeKYC.ImageFilter...)
}
public struct ScaledToSizeFilter : LVTeKYC.ImageFilter, LVTeKYC.Sizable {
  public let size: CoreGraphics.CGSize
  public init(size: CoreGraphics.CGSize)
  public var filter: (LVTeKYC.Image) -> LVTeKYC.Image {
    get
  }
}
public struct AspectScaledToFitSizeFilter : LVTeKYC.ImageFilter, LVTeKYC.Sizable {
  public let size: CoreGraphics.CGSize
  public init(size: CoreGraphics.CGSize)
  public var filter: (LVTeKYC.Image) -> LVTeKYC.Image {
    get
  }
}
public struct AspectScaledToFillSizeFilter : LVTeKYC.ImageFilter, LVTeKYC.Sizable {
  public let size: CoreGraphics.CGSize
  public init(size: CoreGraphics.CGSize)
  public var filter: (LVTeKYC.Image) -> LVTeKYC.Image {
    get
  }
}
public struct RoundedCornersFilter : LVTeKYC.ImageFilter, LVTeKYC.Roundable {
  public let radius: CoreGraphics.CGFloat
  public let divideRadiusByImageScale: Swift.Bool
  public init(radius: CoreGraphics.CGFloat, divideRadiusByImageScale: Swift.Bool = false)
  public var filter: (LVTeKYC.Image) -> LVTeKYC.Image {
    get
  }
  public var identifier: Swift.String {
    get
  }
}
public struct CircleFilter : LVTeKYC.ImageFilter {
  public init()
  public var filter: (LVTeKYC.Image) -> LVTeKYC.Image {
    get
  }
}
@available(iOS 9.0, *)
public protocol CoreImageFilter : LVTeKYC.ImageFilter {
  var filterName: Swift.String { get }
  var parameters: [Swift.String : Any] { get }
}
@available(iOS 9.0, *)
extension ImageFilter where Self : LVTeKYC.CoreImageFilter {
  public var filter: (LVTeKYC.Image) -> LVTeKYC.Image {
    get
  }
  public var identifier: Swift.String {
    get
  }
}
@available(iOS 9.0, *)
public struct BlurFilter : LVTeKYC.ImageFilter, LVTeKYC.CoreImageFilter {
  public let filterName: Swift.String
  public let parameters: [Swift.String : Any]
  public init(blurRadius: Swift.UInt = 10)
}
public struct ScaledToSizeWithRoundedCornersFilter : LVTeKYC.CompositeImageFilter {
  public init(size: CoreGraphics.CGSize, radius: CoreGraphics.CGFloat, divideRadiusByImageScale: Swift.Bool = false)
  public let filters: [LVTeKYC.ImageFilter]
}
public struct AspectScaledToFillSizeWithRoundedCornersFilter : LVTeKYC.CompositeImageFilter {
  public init(size: CoreGraphics.CGSize, radius: CoreGraphics.CGFloat, divideRadiusByImageScale: Swift.Bool = false)
  public let filters: [LVTeKYC.ImageFilter]
}
public struct ScaledToSizeCircleFilter : LVTeKYC.CompositeImageFilter {
  public init(size: CoreGraphics.CGSize)
  public let filters: [LVTeKYC.ImageFilter]
}
public struct AspectScaledToFillSizeCircleFilter : LVTeKYC.CompositeImageFilter {
  public init(size: CoreGraphics.CGSize)
  public let filters: [LVTeKYC.ImageFilter]
}
extension DateFormatter {
  convenience public init(withFormat format: Swift.String, locale: Swift.String)
}
open class ISO8601DateTransform : LVTeKYC.DateFormatterTransform {
  public init()
  @objc deinit
  override public init(dateFormatter: Foundation.DateFormatter)
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> LVTeKYC.Result<Self.SerializedObject> { get }
}
public struct DataResponseSerializer<Value> : LVTeKYC.DataResponseSerializerProtocol {
  public typealias SerializedObject = Value
  public var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> LVTeKYC.Result<Value>
  public init(serializeResponse: @escaping (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> LVTeKYC.Result<Value>)
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> LVTeKYC.Result<Self.SerializedObject> { get }
}
public struct DownloadResponseSerializer<Value> : LVTeKYC.DownloadResponseSerializerProtocol {
  public typealias SerializedObject = Value
  public var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> LVTeKYC.Result<Value>
  public init(serializeResponse: @escaping (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> LVTeKYC.Result<Value>)
}
extension DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (LVTeKYC.DefaultDataResponse) -> Swift.Void) -> Self
  @discardableResult
  public func response<T>(queue: Dispatch.DispatchQueue? = nil, responseSerializer: T, completionHandler: @escaping (LVTeKYC.DataResponse<T.SerializedObject>) -> Swift.Void) -> Self where T : LVTeKYC.DataResponseSerializerProtocol
}
extension DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (LVTeKYC.DefaultDownloadResponse) -> Swift.Void) -> Self
  @discardableResult
  public func response<T>(queue: Dispatch.DispatchQueue? = nil, responseSerializer: T, completionHandler: @escaping (LVTeKYC.DownloadResponse<T.SerializedObject>) -> Swift.Void) -> Self where T : LVTeKYC.DownloadResponseSerializerProtocol
}
extension Request {
  public static func serializeResponseData(response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> LVTeKYC.Result<Foundation.Data>
}
extension DataRequest {
  public static func dataResponseSerializer() -> LVTeKYC.DataResponseSerializer<Foundation.Data>
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (LVTeKYC.DataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  public static func dataResponseSerializer() -> LVTeKYC.DownloadResponseSerializer<Foundation.Data>
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (LVTeKYC.DownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension Request {
  public static func serializeResponseString(encoding: Swift.String.Encoding?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> LVTeKYC.Result<Swift.String>
}
extension DataRequest {
  public static func stringResponseSerializer(encoding: Swift.String.Encoding? = nil) -> LVTeKYC.DataResponseSerializer<Swift.String>
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue? = nil, encoding: Swift.String.Encoding? = nil, completionHandler: @escaping (LVTeKYC.DataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  public static func stringResponseSerializer(encoding: Swift.String.Encoding? = nil) -> LVTeKYC.DownloadResponseSerializer<Swift.String>
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue? = nil, encoding: Swift.String.Encoding? = nil, completionHandler: @escaping (LVTeKYC.DownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
extension Request {
  public static func serializeResponseJSON(options: Foundation.JSONSerialization.ReadingOptions, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> LVTeKYC.Result<Any>
}
extension DataRequest {
  public static func jsonResponseSerializer(options: Foundation.JSONSerialization.ReadingOptions = .allowFragments) -> LVTeKYC.DataResponseSerializer<Any>
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue? = nil, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (LVTeKYC.DataResponse<Any>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  public static func jsonResponseSerializer(options: Foundation.JSONSerialization.ReadingOptions = .allowFragments) -> LVTeKYC.DownloadResponseSerializer<Any>
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue? = nil, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (LVTeKYC.DownloadResponse<Any>) -> Swift.Void) -> Self
}
extension Request {
  public static func serializeResponsePropertyList(options: Foundation.PropertyListSerialization.ReadOptions, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> LVTeKYC.Result<Any>
}
extension DataRequest {
  public static func propertyListResponseSerializer(options: Foundation.PropertyListSerialization.ReadOptions = []) -> LVTeKYC.DataResponseSerializer<Any>
  @discardableResult
  public func responsePropertyList(queue: Dispatch.DispatchQueue? = nil, options: Foundation.PropertyListSerialization.ReadOptions = [], completionHandler: @escaping (LVTeKYC.DataResponse<Any>) -> Swift.Void) -> Self
}
extension DownloadRequest {
  public static func propertyListResponseSerializer(options: Foundation.PropertyListSerialization.ReadOptions = []) -> LVTeKYC.DownloadResponseSerializer<Any>
  @discardableResult
  public func responsePropertyList(queue: Dispatch.DispatchQueue? = nil, options: Foundation.PropertyListSerialization.ReadOptions = [], completionHandler: @escaping (LVTeKYC.DownloadResponse<Any>) -> Swift.Void) -> Self
}
open class TransformOf<ObjectType, JSONType> : LVTeKYC.TransformType {
  public typealias Object = ObjectType
  public typealias JSON = JSONType
  public init(fromJSON: @escaping (JSONType?) -> ObjectType?, toJSON: @escaping (ObjectType?) -> JSONType?)
  open func transformFromJSON(_ value: Any?) -> ObjectType?
  open func transformToJSON(_ value: ObjectType?) -> JSONType?
  @objc deinit
}
open class URLTransform : LVTeKYC.TransformType {
  public typealias Object = Foundation.URL
  public typealias JSON = Swift.String
  public init(shouldEncodeURLString: Swift.Bool = false, allowedCharacterSet: Foundation.CharacterSet = .urlQueryAllowed)
  open func transformFromJSON(_ value: Any?) -> Foundation.URL?
  open func transformToJSON(_ value: Foundation.URL?) -> Swift.String?
  @objc deinit
}
extension UINavigationController {
  @objc dynamic public func lvtEKYC_pushViewController(_ newController: UIKit.UIViewController, animated flag: Swift.Bool = true)
  @objc dynamic public func lvtEKYC_popViewController(animated flag: Swift.Bool = true)
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(LVTeKYC.NetworkReachabilityManager.ConnectionType)
  }
  public enum ConnectionType {
    case ethernetOrWiFi
    case wwan
    public static func == (a: LVTeKYC.NetworkReachabilityManager.ConnectionType, b: LVTeKYC.NetworkReachabilityManager.ConnectionType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public typealias Listener = (LVTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnWWAN: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  open var networkReachabilityStatus: LVTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  open var listenerQueue: Dispatch.DispatchQueue
  open var listener: LVTeKYC.NetworkReachabilityManager.Listener?
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var previousFlags: SystemConfiguration.SCNetworkReachabilityFlags
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening() -> Swift.Bool
  open func stopListening()
}
extension NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
}
public func == (lhs: LVTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus, rhs: LVTeKYC.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class LVTEKYCCustomerData : ObjectiveC.NSObject, LVTeKYC.Mappable, Swift.Codable {
  @objc public var customerName: Swift.String?
  @objc public var uniqueValue: Swift.String?
  @objc public var uniqueType: Swift.String?
  @objc public var people: Swift.String?
  @objc public var addressCity: Swift.String?
  @objc public var addressDistrict: Swift.String?
  @objc public var addressPrecinct: Swift.String?
  @objc public var fullAddress: Swift.String?
  @objc public var placeId: Swift.String?
  @objc public var placeIdDistrict: Swift.String?
  @objc public var placeIdProvince: Swift.String?
  @objc public var dob: Swift.String?
  @objc public var issueDate: Swift.String?
  @objc public var issuePlace: Swift.String?
  @objc public var nationality: Swift.String?
  @objc public var email: Swift.String?
  @objc public var gender: Swift.String?
  @objc public var nativePlace: Swift.String?
  @objc public var nationalityName: Swift.String?
  @objc public var expiryDate: Swift.String?
  @objc public var jobCode: Swift.String?
  @objc public var positionCode: Swift.String?
  @objc public var currentAddress: Swift.String?
  @objc public var ekycAttributeLs: [LVTeKYC.LVTEKYCCustomerDataAttr]?
  @objc public var isUSA: Swift.Int
  @objc public var currentAddressLine: Swift.String?
  @objc public var currentPlaceId: Swift.String?
  @objc public var isEmailVerify: Swift.String?
  @objc public var addressLine: Swift.String?
  required public init?(map: LVTeKYC.Map)
  public func mapping(map: LVTeKYC.Map)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
open class NSDecimalNumberTransform : LVTeKYC.TransformType {
  public typealias Object = Foundation.NSDecimalNumber
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.NSDecimalNumber?
  open func transformToJSON(_ value: Foundation.NSDecimalNumber?) -> Swift.String?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class SessionDelegate : ObjectiveC.NSObject {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var sessionDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLAuthenticationChallenge) -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?))?
  open var sessionDidReceiveChallengeWithCompletion: ((Foundation.URLSession, Foundation.URLAuthenticationChallenge, @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void) -> Swift.Void)?
  open var sessionDidFinishEventsForBackgroundURLSession: ((Foundation.URLSession) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Foundation.URLRequest?)?
  open var taskWillPerformHTTPRedirectionWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?))?
  open var taskDidReceiveChallengeWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge, @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Foundation.InputStream?)?
  open var taskNeedNewBodyStreamWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, @escaping (Foundation.InputStream?) -> Swift.Void) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var dataTaskDidReceiveResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLResponse) -> Foundation.URLSession.ResponseDisposition)?
  open var dataTaskDidReceiveResponseWithCompletion: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLResponse, @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void) -> Swift.Void)?
  open var dataTaskDidBecomeDownloadTask: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLSessionDownloadTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)?
  open var dataTaskWillCacheResponseWithCompletion: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse, @escaping (Foundation.CachedURLResponse?) -> Swift.Void) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  open var streamTaskReadClosed: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  open var streamTaskWriteClosed: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  open var streamTaskBetterRouteDiscovered: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
  open var streamTaskDidBecomeInputAndOutputStreams: ((Foundation.URLSession, Foundation.URLSessionStreamTask, Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? {
    get
    set
  }
  open subscript(task: Foundation.URLSessionTask) -> LVTeKYC.Request? {
    get
    set
  }
  @objc override dynamic public init()
  @objc override dynamic open func responds(to selector: ObjectiveC.Selector) -> Swift.Bool
  @objc deinit
}
extension SessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSessionDidFinishEvents(forBackgroundURLSession session: Foundation.URLSession)
}
extension SessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @available(iOS 10.0, OSX 10.12, tvOS 10.0, *)
  @objc(URLSession:task:didFinishCollectingMetrics:) dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
}
extension SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didBecome downloadTask: Foundation.URLSessionDownloadTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
}
@available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
extension SessionDelegate : Foundation.URLSessionStreamDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, readClosedFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, writeClosedFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, betterRouteDiscoveredFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, streamTask: Foundation.URLSessionStreamTask, didBecome inputStream: Foundation.InputStream, outputStream: Foundation.OutputStream)
}
public protocol TransformType {
  associatedtype Object
  associatedtype JSON
  func transformFromJSON(_ value: Any?) -> Self.Object?
  func transformToJSON(_ value: Self.Object?) -> Self.JSON?
}
extension UIColor {
  convenience public init(hex: Swift.Int, alpha: CoreGraphics.CGFloat = 1.0)
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension String : LVTeKYC.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URL : LVTeKYC.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URLComponents : LVTeKYC.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension URLRequest : LVTeKYC.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension URLRequest {
  public init(url: LVTeKYC.URLConvertible, method: LVTeKYC.HTTPMethod, headers: LVTeKYC.HTTPHeaders? = nil) throws
}
infix operator <- : DefaultPrecedence
infix operator >>> : DefaultPrecedence
public func <- <T>(left: inout T, right: LVTeKYC.Map)
public func >>> <T>(left: T, right: LVTeKYC.Map)
public func <- <T>(left: inout T?, right: LVTeKYC.Map)
public func >>> <T>(left: T?, right: LVTeKYC.Map)
public func <- <T>(left: inout T, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func >>> <T>(left: T, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <- <T>(left: inout T?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func >>> <T>(left: T?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <- <T>(left: inout Swift.Array<T>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func >>> <T>(left: Swift.Array<T>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <- <T>(left: inout Swift.Array<T>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func >>> <T>(left: Swift.Array<T>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable
public func <- <T>(left: inout Swift.Set<T>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable, T : Swift.Hashable
public func >>> <T>(left: Swift.Set<T>, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable, T : Swift.Hashable
public func <- <T>(left: inout Swift.Set<T>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable, T : Swift.Hashable
public func >>> <T>(left: Swift.Set<T>?, right: LVTeKYC.Map) where T : LVTeKYC.BaseMappable, T : Swift.Hashable
open class CustomDateFormatTransform : LVTeKYC.DateFormatterTransform {
  public init(formatString: Swift.String)
  @objc deinit
  override public init(dateFormatter: Foundation.DateFormatter)
}
public struct Timeline {
  public let requestStartTime: CoreFoundation.CFAbsoluteTime
  public let initialResponseTime: CoreFoundation.CFAbsoluteTime
  public let requestCompletedTime: CoreFoundation.CFAbsoluteTime
  public let serializationCompletedTime: CoreFoundation.CFAbsoluteTime
  public let latency: Foundation.TimeInterval
  public let requestDuration: Foundation.TimeInterval
  public let serializationDuration: Foundation.TimeInterval
  public let totalDuration: Foundation.TimeInterval
  public init(requestStartTime: CoreFoundation.CFAbsoluteTime = 0.0, initialResponseTime: CoreFoundation.CFAbsoluteTime = 0.0, requestCompletedTime: CoreFoundation.CFAbsoluteTime = 0.0, serializationCompletedTime: CoreFoundation.CFAbsoluteTime = 0.0)
}
extension Timeline : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Timeline : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol ImageCache {
  func add(_ image: LVTeKYC.Image, withIdentifier identifier: Swift.String)
  func removeImage(withIdentifier identifier: Swift.String) -> Swift.Bool
  @discardableResult
  func removeAllImages() -> Swift.Bool
  func image(withIdentifier identifier: Swift.String) -> LVTeKYC.Image?
}
public protocol ImageRequestCache : LVTeKYC.ImageCache {
  func add(_ image: LVTeKYC.Image, for request: Foundation.URLRequest, withIdentifier identifier: Swift.String?)
  func removeImage(for request: Foundation.URLRequest, withIdentifier identifier: Swift.String?) -> Swift.Bool
  func image(for request: Foundation.URLRequest, withIdentifier identifier: Swift.String?) -> LVTeKYC.Image?
}
open class AutoPurgingImageCache : LVTeKYC.ImageRequestCache {
  open var memoryUsage: Swift.UInt64 {
    get
  }
  final public let memoryCapacity: Swift.UInt64
  final public let preferredMemoryUsageAfterPurge: Swift.UInt64
  public init(memoryCapacity: Swift.UInt64 = 100_000_000, preferredMemoryUsageAfterPurge: Swift.UInt64 = 60_000_000)
  @objc deinit
  open func add(_ image: LVTeKYC.Image, for request: Foundation.URLRequest, withIdentifier identifier: Swift.String? = nil)
  open func add(_ image: LVTeKYC.Image, withIdentifier identifier: Swift.String)
  @discardableResult
  open func removeImage(for request: Foundation.URLRequest, withIdentifier identifier: Swift.String?) -> Swift.Bool
  @discardableResult
  open func removeImages(matching request: Foundation.URLRequest) -> Swift.Bool
  @discardableResult
  open func removeImage(withIdentifier identifier: Swift.String) -> Swift.Bool
  @discardableResult
  @objc open func removeAllImages() -> Swift.Bool
  open func image(for request: Foundation.URLRequest, withIdentifier identifier: Swift.String? = nil) -> LVTeKYC.Image?
  open func image(withIdentifier identifier: Swift.String) -> LVTeKYC.Image?
  open func imageCacheKey(for request: Foundation.URLRequest, withIdentifier identifier: Swift.String?) -> Swift.String
}
extension NSNotification.Name {
  public struct Task {
    public static let DidResume: Foundation.Notification.Name
    public static let DidSuspend: Foundation.Notification.Name
    public static let DidCancel: Foundation.Notification.Name
    public static let DidComplete: Foundation.Notification.Name
  }
}
extension Notification {
  public struct Key {
    public static let Task: Swift.String
    public static let ResponseData: Swift.String
  }
}
public func <- <Transform>(left: inout Transform.Object, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func >>> <Transform>(left: Transform.Object, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func <- <Transform>(left: inout Transform.Object?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func >>> <Transform>(left: Transform.Object?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func <- <Transform>(left: inout [Transform.Object], right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func >>> <Transform>(left: [Transform.Object], right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func <- <Transform>(left: inout [Transform.Object]?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func >>> <Transform>(left: [Transform.Object]?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object], right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object], right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object]?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object]?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func <- <Transform>(left: inout Transform.Object, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func >>> <Transform>(left: Transform.Object, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func <- <Transform>(left: inout Transform.Object?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func >>> <Transform>(left: Transform.Object?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable
public func <- <Transform>(left: inout [[Transform.Object]], right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func >>> <Transform>(left: [[Transform.Object]], right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func <- <Transform>(left: inout [[Transform.Object]]?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func >>> <Transform>(left: [[Transform.Object]]?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType
public func <- <Transform>(left: inout Swift.Set<Transform.Object>, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable, Transform.Object : Swift.Hashable
public func >>> <Transform>(left: Swift.Set<Transform.Object>, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable, Transform.Object : Swift.Hashable
public func <- <Transform>(left: inout Swift.Set<Transform.Object>?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable, Transform.Object : Swift.Hashable
public func >>> <Transform>(left: Swift.Set<Transform.Object>?, right: (LVTeKYC.Map, Transform)) where Transform : LVTeKYC.TransformType, Transform.Object : LVTeKYC.BaseMappable, Transform.Object : Swift.Hashable
public enum LivenessAction : Swift.String {
  case turnLeft
  case turnRight
  case smile
  case tiltHeadLeft
  case tiltHeadRight
  case lookAhead
  case closeEyes
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class LVTEKYCCustomerDataAttr : ObjectiveC.NSObject, LVTeKYC.Mappable, Swift.Codable {
  @objc public var name: Swift.String?
  @objc public var orgValue: Swift.String?
  public func mapping(map: LVTeKYC.Map)
  required public init?(map: LVTeKYC.Map)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension NSLayoutConstraint {
  public func active()
}
public protocol XibController {
}
extension XibController where Self : UIKit.UIViewController {
  public static func newInstance() -> Self
}
@_inheritsConvenienceInitializers @objc public class SDKInitParams : ObjectiveC.NSObject {
  @objc public var sdkId: Swift.String?
  @objc public var sdkSecret: Swift.String?
  @objc public var publicKey: Swift.String?
  @objc public var partnerSignature: Swift.String?
  @objc override dynamic public init()
  @objc public init(sdkId: Swift.String, sdkSecret: Swift.String, publicKey: Swift.String, partnerSignature: Swift.String)
  @objc deinit
}
open class GDateTransform : LVTeKYC.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  public init(format: Swift.String)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
public func <- <T>(left: inout T, right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: T, right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout T?, right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: T?, right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [T], right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [T], right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [T]?, right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [T]?, right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [Swift.String : T], right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [Swift.String : T], right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [Swift.String : T]?, right: LVTeKYC.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [Swift.String : T]?, right: LVTeKYC.Map) where T : Swift.RawRepresentable
@objc @_inheritsConvenienceInitializers @objcMembers public class SampleSDKLoginResUserInfo : ObjectiveC.NSObject, Swift.Codable {
  @objc public var username: Swift.String?, userId: Swift.String?, fullName: Swift.String?, password: Swift.String?
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc @objcMembers public class SampleSDKLoginRes : ObjectiveC.NSObject, Swift.Codable {
  @objc public var responseCode: Swift.String
  @objc public var responseMessage: Swift.String?, responseTime: Swift.String?, signature: Swift.String?
  @objc public var userInfo: LVTeKYC.SampleSDKLoginResUserInfo
  @objc public var userSessionId: Swift.String?
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc @_hasMissingDesignatedInitializers open class TaskDelegate : ObjectiveC.NSObject {
  final public let queue: Foundation.OperationQueue
  public var data: Foundation.Data? {
    get
  }
  public var error: Swift.Error?
  @objc override dynamic public init()
  @objc deinit
}
public protocol BaseMappable {
  mutating func mapping(map: LVTeKYC.Map)
}
public protocol Mappable : LVTeKYC.BaseMappable {
  init?(map: LVTeKYC.Map)
}
public protocol StaticMappable : LVTeKYC.BaseMappable {
  static func objectForMapping(map: LVTeKYC.Map) -> LVTeKYC.BaseMappable?
}
extension Mappable {
  public init?(JSONString: Swift.String, context: LVTeKYC.MapContext? = nil)
  public init?(JSON: [Swift.String : Any], context: LVTeKYC.MapContext? = nil)
}
extension BaseMappable {
  public func toJSON() -> [Swift.String : Any]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Array where Element : LVTeKYC.BaseMappable {
  public init?(JSONString: Swift.String, context: LVTeKYC.MapContext? = nil)
  public init(JSONArray: [[Swift.String : Any]], context: LVTeKYC.MapContext? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Set where Element : LVTeKYC.BaseMappable {
  public init?(JSONString: Swift.String, context: LVTeKYC.MapContext? = nil)
  public init?(JSONArray: [[Swift.String : Any]], context: LVTeKYC.MapContext? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
public enum HTTPMethod : Swift.String {
  case options
  case get
  case head
  case post
  case put
  case patch
  case delete
  case trace
  case connect
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: LVTeKYC.URLRequestConvertible, with parameters: LVTeKYC.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : LVTeKYC.ParameterEncoding {
  public enum Destination {
    case methodDependent, queryString, httpBody
    public static func == (a: LVTeKYC.URLEncoding.Destination, b: LVTeKYC.URLEncoding.Destination) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum ArrayEncoding {
    case brackets, noBrackets
    public static func == (a: LVTeKYC.URLEncoding.ArrayEncoding, b: LVTeKYC.URLEncoding.ArrayEncoding) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum BoolEncoding {
    case numeric, literal
    public static func == (a: LVTeKYC.URLEncoding.BoolEncoding, b: LVTeKYC.URLEncoding.BoolEncoding) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static var `default`: LVTeKYC.URLEncoding {
    get
  }
  public static var methodDependent: LVTeKYC.URLEncoding {
    get
  }
  public static var queryString: LVTeKYC.URLEncoding {
    get
  }
  public static var httpBody: LVTeKYC.URLEncoding {
    get
  }
  public let destination: LVTeKYC.URLEncoding.Destination
  public let arrayEncoding: LVTeKYC.URLEncoding.ArrayEncoding
  public let boolEncoding: LVTeKYC.URLEncoding.BoolEncoding
  public init(destination: LVTeKYC.URLEncoding.Destination = .methodDependent, arrayEncoding: LVTeKYC.URLEncoding.ArrayEncoding = .brackets, boolEncoding: LVTeKYC.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: LVTeKYC.URLRequestConvertible, with parameters: LVTeKYC.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : LVTeKYC.ParameterEncoding {
  public static var `default`: LVTeKYC.JSONEncoding {
    get
  }
  public static var prettyPrinted: LVTeKYC.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: LVTeKYC.URLRequestConvertible, with parameters: LVTeKYC.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: LVTeKYC.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
public struct PropertyListEncoding : LVTeKYC.ParameterEncoding {
  public static var `default`: LVTeKYC.PropertyListEncoding {
    get
  }
  public static var xml: LVTeKYC.PropertyListEncoding {
    get
  }
  public static var binary: LVTeKYC.PropertyListEncoding {
    get
  }
  public let format: Foundation.PropertyListSerialization.PropertyListFormat
  public let options: Foundation.PropertyListSerialization.WriteOptions
  public init(format: Foundation.PropertyListSerialization.PropertyListFormat = .xml, options: Foundation.PropertyListSerialization.WriteOptions = 0)
  public func encode(_ urlRequest: LVTeKYC.URLRequestConvertible, with parameters: LVTeKYC.Parameters?) throws -> Foundation.URLRequest
}
@_hasMissingDesignatedInitializers @objc public class CheckSdkInitResult : ObjectiveC.NSObject, Swift.Codable {
  @objc public var isSdkInit: Swift.Bool
  @objc public var sdkId: Swift.String?
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
open class ServerTrustPolicyManager {
  final public let policies: [Swift.String : LVTeKYC.ServerTrustPolicy]
  public init(policies: [Swift.String : LVTeKYC.ServerTrustPolicy])
  open func serverTrustPolicy(forHost host: Swift.String) -> LVTeKYC.ServerTrustPolicy?
  @objc deinit
}
public enum ServerTrustPolicy {
  case performDefaultEvaluation(validateHost: Swift.Bool)
  case performRevokedEvaluation(validateHost: Swift.Bool, revocationFlags: CoreFoundation.CFOptionFlags)
  case pinCertificates(certificates: [Security.SecCertificate], validateCertificateChain: Swift.Bool, validateHost: Swift.Bool)
  case pinPublicKeys(publicKeys: [Security.SecKey], validateCertificateChain: Swift.Bool, validateHost: Swift.Bool)
  case disableEvaluation
  case customEvaluation((Security.SecTrust, Swift.String) -> Swift.Bool)
  public static func certificates(in bundle: Foundation.Bundle = Bundle.main) -> [Security.SecCertificate]
  public static func publicKeys(in bundle: Foundation.Bundle = Bundle.main) -> [Security.SecKey]
  public func evaluate(_ serverTrust: Security.SecTrust, forHost host: Swift.String) -> Swift.Bool
}
open class CodableTransform<T> : LVTeKYC.TransformType where T : Swift.Decodable, T : Swift.Encodable {
  public typealias Object = T
  public typealias JSON = Any
  public init()
  open func transformFromJSON(_ value: Any?) -> LVTeKYC.CodableTransform<T>.Object?
  open func transformToJSON(_ value: T?) -> LVTeKYC.CodableTransform<T>.JSON?
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(KeychainHelper) public class KeychainHelper : ObjectiveC.NSObject {
  @objc @_inheritsConvenienceInitializers public class ExistResult : ObjectiveC.NSObject {
    public var result: Swift.Bool {
      get
    }
    public var status: Darwin.OSStatus? {
      get
    }
    @objc override dynamic public init()
    @objc deinit
  }
  @objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class QueryItem : ObjectiveC.NSObject {
    public var prompMessage: Swift.String?
    public init(key: Swift.String, value: Foundation.Data? = nil, service: Swift.String? = nil, accessGroup: Swift.String? = nil)
    public func setAccessControlWithFlag(_ flags: Security.SecAccessControlCreateFlags)
    @objc deinit
  }
  @objc deinit
  @objc override dynamic public init()
}
extension KeychainHelper {
  public static func set(key: Swift.String, value: Foundation.Data, isProtectedBio: Swift.Bool = false) throws
  public static func set(key: Swift.String, value: Foundation.Data, flags: Security.SecAccessControlCreateFlags?) throws
  public static func set(_ item: LVTeKYC.KeychainHelper.QueryItem) throws
  public static func get(_ item: LVTeKYC.KeychainHelper.QueryItem) throws -> Foundation.Data?
  public static func getStringValue(_ item: LVTeKYC.KeychainHelper.QueryItem) throws -> Swift.String?
  public static func get(key: Swift.String, prompMessage: Swift.String? = nil) throws -> Foundation.Data?
  public static func getStringValue(key: Swift.String, prompMessage: Swift.String? = nil) throws -> Swift.String?
  @discardableResult
  public static func delete(_ item: LVTeKYC.KeychainHelper.QueryItem) -> Swift.Bool
  @discardableResult
  public static func delete(key: Swift.String) -> Swift.Bool
  public static func isExistItem(_ key: Swift.String) -> LVTeKYC.KeychainHelper.ExistResult
}
extension KeychainHelper {
  @objc public static func getPublicKeyString(tag: Swift.String) -> Swift.String?
}
@objc public class SampleSDKLoginReq : ObjectiveC.NSObject, Swift.Codable {
  final public let userName: Swift.String, password: Swift.String
  public init(userName: Swift.String, password: Swift.String)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum Result<Value> {
  case success(Value)
  case failure(Swift.Error)
  public var isSuccess: Swift.Bool {
    get
  }
  public var isFailure: Swift.Bool {
    get
  }
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
}
extension Result : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Result : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Result {
  public init(value: () throws -> Value)
  public func unwrap() throws -> Value
  public func map<T>(_ transform: (Value) -> T) -> LVTeKYC.Result<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> LVTeKYC.Result<T>
  public func mapError<T>(_ transform: (Swift.Error) -> T) -> LVTeKYC.Result<Value> where T : Swift.Error
  public func flatMapError<T>(_ transform: (Swift.Error) throws -> T) -> LVTeKYC.Result<Value> where T : Swift.Error
  @discardableResult
  public func withValue(_ closure: (Value) throws -> Swift.Void) rethrows -> LVTeKYC.Result<Value>
  @discardableResult
  public func withError(_ closure: (Swift.Error) throws -> Swift.Void) rethrows -> LVTeKYC.Result<Value>
  @discardableResult
  public func ifSuccess(_ closure: () throws -> Swift.Void) rethrows -> LVTeKYC.Result<Value>
  @discardableResult
  public func ifFailure(_ closure: () throws -> Swift.Void) rethrows -> LVTeKYC.Result<Value>
}
@objc public enum FMLCPoseItem : ObjectiveC.NSInteger {
  case smile, closeEyes, tiltHeadLeft, tiltHeadRight, turnLeft, turnRight
  public typealias RawValue = ObjectiveC.NSInteger
  public init?(rawValue: ObjectiveC.NSInteger)
  public var rawValue: ObjectiveC.NSInteger {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class SDKError : ObjectiveC.NSObject, Swift.Codable {
  @objc public var code: Swift.String? {
    @objc get
  }
  @objc public var message: Swift.String? {
    @objc get
  }
  @objc override dynamic public init()
  @objc public init(code: Swift.String, message: Swift.String)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public struct DictionaryTransform<Key, Value> : LVTeKYC.TransformType where Key : Swift.Hashable, Key : Swift.RawRepresentable, Value : LVTeKYC.Mappable, Key.RawValue == Swift.String {
  public init()
  public func transformFromJSON(_ value: Any?) -> [Key : Value]?
  public func transformToJSON(_ value: [Key : Value]?) -> Any?
  public typealias Object = Swift.Dictionary<Key, Value>
  public typealias JSON = Any
}
@objc @_inheritsConvenienceInitializers public class SampleSDKUpdateResultRes : ObjectiveC.NSObject, Swift.Codable {
  public var responseCode: Swift.String?
  public var responseMessage: Swift.String?
  public var responseTime: Swift.String?
  public var signature: Swift.String?
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest) throws -> Foundation.URLRequest
}
public typealias RequestRetryCompletion = (Swift.Bool, Foundation.TimeInterval) -> Swift.Void
public protocol RequestRetrier {
  func should(_ manager: LVTeKYC.AlamofireSessionManager, retry request: LVTeKYC.Request, with error: Swift.Error, completion: @escaping LVTeKYC.RequestRetryCompletion)
}
public typealias HTTPHeaders = [Swift.String : Swift.String]
@_hasMissingDesignatedInitializers open class Request {
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  open var delegate: LVTeKYC.TaskDelegate {
    get
  }
  open var task: Foundation.URLSessionTask? {
    get
  }
  final public let session: Foundation.URLSession
  open var request: Foundation.URLRequest? {
    get
  }
  open var response: Foundation.HTTPURLResponse? {
    get
  }
  open var retryCount: Swift.UInt {
    get
  }
  @discardableResult
  open func authenticate(user: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  open func authenticate(usingCredential credential: Foundation.URLCredential) -> Self
  open class func authorizationHeader(user: Swift.String, password: Swift.String) -> (key: Swift.String, value: Swift.String)?
  open func resume()
  open func suspend()
  open func cancel()
  @objc deinit
}
extension Request : Swift.CustomStringConvertible {
  open var description: Swift.String {
    get
  }
}
extension Request : Swift.CustomDebugStringConvertible {
  open var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class DataRequest : LVTeKYC.Request {
  override open var request: Foundation.URLRequest? {
    get
  }
  open var progress: Foundation.Progress {
    get
  }
  @discardableResult
  open func stream(closure: ((Foundation.Data) -> Swift.Void)? = nil) -> Self
  @discardableResult
  open func downloadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping LVTeKYC.DataRequest.ProgressHandler) -> Self
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class DownloadRequest : LVTeKYC.Request {
  public struct DownloadOptions : Swift.OptionSet {
    public let rawValue: Swift.UInt
    public static let createIntermediateDirectories: LVTeKYC.DownloadRequest.DownloadOptions
    public static let removePreviousFile: LVTeKYC.DownloadRequest.DownloadOptions
    public init(rawValue: Swift.UInt)
    public typealias Element = LVTeKYC.DownloadRequest.DownloadOptions
    public typealias ArrayLiteralElement = LVTeKYC.DownloadRequest.DownloadOptions
    public typealias RawValue = Swift.UInt
  }
  public typealias DownloadFileDestination = (Foundation.URL, Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: LVTeKYC.DownloadRequest.DownloadOptions)
  override open var request: Foundation.URLRequest? {
    get
  }
  open var resumeData: Foundation.Data? {
    get
  }
  open var progress: Foundation.Progress {
    get
  }
  override open func cancel()
  open func cancel(createResumeData: Swift.Bool)
  @discardableResult
  open func downloadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping LVTeKYC.DownloadRequest.ProgressHandler) -> Self
  open class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask) -> LVTeKYC.DownloadRequest.DownloadFileDestination
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class UploadRequest : LVTeKYC.DataRequest {
  override open var request: Foundation.URLRequest? {
    get
  }
  open var uploadProgress: Foundation.Progress {
    get
  }
  @discardableResult
  open func uploadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping LVTeKYC.UploadRequest.ProgressHandler) -> Self
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 9.0, OSX 10.11, tvOS 9.0, *)
open class StreamRequest : LVTeKYC.Request {
  @objc deinit
}
extension Request {
  public enum ValidationResult {
    case success
    case failure(Swift.Error)
  }
}
extension DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> LVTeKYC.Request.ValidationResult
  @discardableResult
  public func validate(_ validation: @escaping LVTeKYC.DataRequest.Validation) -> Self
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension DownloadRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, Foundation.URL?) -> LVTeKYC.Request.ValidationResult
  @discardableResult
  public func validate(_ validation: @escaping LVTeKYC.DownloadRequest.Validation) -> Self
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
@_inheritsConvenienceInitializers @objc public class SDKResultImage : ObjectiveC.NSObject {
  @objc public var label: Swift.String?
  @objc public var image: UIKit.UIImage?
  @objc override dynamic public init()
  @objc public init(label: Swift.String?, image: UIKit.UIImage?)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class SDKResultData : ObjectiveC.NSObject {
  @objc public var customerData: LVTeKYC.LVTEKYCCustomerData?
  @objc public var faceData: LVTeKYC.LVTEKYCFaceData?
  @objc public var idFrontImage: UIKit.UIImage?
  @objc public var idBackImage: UIKit.UIImage?
  @objc public var liveImages: [LVTeKYC.SDKResultImage]?
  @objc public var signature: Swift.String?
  @objc public var ekycResultTime: Swift.String?
  @objc public var ekycSession: Swift.String?
  @objc override dynamic public init()
  @objc deinit
}
extension LVTeKYC.ImageDownloader.DownloadPrioritization : Swift.Equatable {}
extension LVTeKYC.ImageDownloader.DownloadPrioritization : Swift.Hashable {}
extension LVTeKYC.AFIError : Swift.Equatable {}
extension LVTeKYC.AFIError : Swift.Hashable {}
extension LVTeKYC.DateTransform.Unit : Swift.Equatable {}
extension LVTeKYC.DateTransform.Unit : Swift.Hashable {}
extension LVTeKYC.DateTransform.Unit : Swift.RawRepresentable {}
extension LVTeKYC.CircleLoadingViewSize : Swift.Equatable {}
extension LVTeKYC.CircleLoadingViewSize : Swift.Hashable {}
extension LVTeKYC.CircleLoadingViewSize : Swift.RawRepresentable {}
extension LVTeKYC.MappingType : Swift.Equatable {}
extension LVTeKYC.MappingType : Swift.Hashable {}
extension LVTeKYC.NetworkReachabilityManager.ConnectionType : Swift.Equatable {}
extension LVTeKYC.NetworkReachabilityManager.ConnectionType : Swift.Hashable {}
extension LVTeKYC.LivenessAction : Swift.Equatable {}
extension LVTeKYC.LivenessAction : Swift.Hashable {}
extension LVTeKYC.LivenessAction : Swift.RawRepresentable {}
extension LVTeKYC.HTTPMethod : Swift.Equatable {}
extension LVTeKYC.HTTPMethod : Swift.Hashable {}
extension LVTeKYC.HTTPMethod : Swift.RawRepresentable {}
extension LVTeKYC.URLEncoding.Destination : Swift.Equatable {}
extension LVTeKYC.URLEncoding.Destination : Swift.Hashable {}
extension LVTeKYC.URLEncoding.ArrayEncoding : Swift.Equatable {}
extension LVTeKYC.URLEncoding.ArrayEncoding : Swift.Hashable {}
extension LVTeKYC.URLEncoding.BoolEncoding : Swift.Equatable {}
extension LVTeKYC.URLEncoding.BoolEncoding : Swift.Hashable {}
extension LVTeKYC.FMLCPoseItem : Swift.Equatable {}
extension LVTeKYC.FMLCPoseItem : Swift.Hashable {}
extension LVTeKYC.FMLCPoseItem : Swift.RawRepresentable {}
